import { Types, Document } from 'mongoose';
export declare type Extract<T> = T extends {
    definition: infer U;
} ? U : never;
export declare type Omit<T, K extends keyof T> = Pick<T, Exclude<keyof T, K>>;
declare type ExtractOptions<T> = T extends {
    options: infer U;
} ? U : never;
declare type DisabledIdOption = {
    _id: false;
};
declare type IsSchemaType<T, IS, NOT> = T extends {
    definition: any;
} ? IS : NOT;
declare type SubdocumentsArrayWithoutId<T extends Types.Subdocument> = {
    [P in keyof Types.DocumentArray<T>]: Omit<T, '_id'>;
};
export declare type ExtractSchema<T> = Extract<T> & (ExtractOptions<T> extends DisabledIdOption ? Omit<Types.Subdocument, '_id'> : Types.Subdocument);
export declare type ArrayOfElements<T> = IsSchemaType<T, ExtractOptions<T> extends DisabledIdOption ? SubdocumentsArrayWithoutId<Extract<T> & Types.Subdocument> : Types.DocumentArray<Extract<T> & Types.Subdocument>, Array<T>>;
declare type ExcludeBaseType<T> = Exclude<T, string | number | Types.ObjectId>;
export declare type ExcludeFromArray<T> = T extends Array<infer U> ? Array<ExcludeBaseType<U>> : ExcludeBaseType<T>;
export declare type PopulateItem<T, P extends keyof T> = Omit<T, P> & {
    [x in P]: ExcludeFromArray<T[x]>;
};
export declare type GetArrayItem<T> = T extends Array<infer U> ? U : never;
export declare type PopulateArray<T, P extends keyof GetArrayItem<T>> = Array<PopulateItem<GetArrayItem<T>, P>>;
export declare type MaybeItem<T> = T extends Array<infer U> ? U : T;
export declare type Populate<T, P> = T extends Array<infer U> ? P extends keyof U ? Array<PopulateItem<U, P>> : T : P extends keyof T ? PopulateItem<T, P> : T;
export declare type ExtractProps<T> = T extends {
    definition: infer D;
} ? D : never;
export declare type ExtractDoc<T> = T extends {
    definition: infer D;
} ? D & Document : never;
export declare type OptionalPropNames<T> = {
    [P in keyof T]: null extends T[P] ? P : never;
}[keyof T];
export declare type RequiredPropNames<T> = {
    [P in keyof T]: null extends T[P] ? never : P;
}[keyof T];
export declare type OptionalProps<T> = {
    [P in OptionalPropNames<T>]: T[P];
};
export declare type RequiredProps<T> = {
    [P in RequiredPropNames<T>]: T[P];
};
export declare type MakeOptional<T> = {
    [P in keyof T]?: T[P];
};
export declare type ConvertObject<T> = {
    [P in RequiredPropNames<T>]: T[P];
} & {
    [P in OptionalPropNames<T>]?: T[P];
};
export {};
